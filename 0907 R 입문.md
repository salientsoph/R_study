# R 설치 후 할 일

## 1. option 설정

1. setting-global options-code-saving-default text encoding: utf-8 로 수정

2. appearance-font size 



## 2. project(폴더) 만들기

1. file-new project-new directory-new project-'Rexam' c드라이브에.

2. file-new file-R script





# R이란

![](C:\Users\salient\Pictures\R.png)

## 1. R vs python

1. __SQL, R__: 데이터가 주인공  

   - 어떤 데이터를 다루느냐, 연산자가 뭐 있는지, 제어문이 뭐 있는지가 R의 절반.

   - 기본 구문이 잘 만들어져 있다. 
   - Javascript 의 함수와 비슷하다.

2. __파이썬 등__: 로직이 주인공



## 2. R의 자료형

1. __문자형(charactar)__: 문자, 문자열

   -> 문자, 문자열 구분하지 않는다.

2. __수치형(numeric)__: 정수(integer), 실수(double)

3. __복소수형(complex)__: 실수 + 허수

4. __논리형(logical)__: 참값, 거짓값



## 3. R의 데이터값

1. __문자형 리터럴__: "가나다", '가나다', '', '123', "abc"
   - 대문자, 소문자 구분 필요
   - 내용 없는 null 문자열도 가능
2. __수치형 리터럴__: 100, 3.14, 0
3. __논리형 리터럴__: TRUE(=T), FALSE(=F)
   - 모두 대문자(파이썬은 첫문자만 대문자, Javascript는 모두 소문자)
4. __NULL__: 데이터 셋(객체)이 비어있음을 의미함
   - R은 class 등은 정의 불가
5. __NA__: Not Available. 아직 정해져있지 않음. 데이터 셋의 내부에 존재하지 않는 값(격측치)를 의미
   - 가장 많이 쓰임
   - 전처리시 NA를 어떻게 처리해야할지가 중요
6. __NaN__: Not A Number. 숫자가 아님. 
   - Inf: 무한대값



## 4. 타입 체크 함수들

1. is.character(x) - 문자형

2. is.logical(x) - 논리형

3. is.numeric(x) - 수치형

4. is.double(x) - 실수형

5. is.integer(x) - 정수형

6. is.null(x)

7. is.na(x) -중요!!! <na 값인가>를 체크함.

8. is.nan(x)

9. is.finite(x)

10. is.infinite(x)



## 5. 자동형 변환 룰

- 문자형(character) >복소수형(complex) >수치형(numeric) > 논리형(logical)

  ex) 문자형 + 수치형 = 문자형



## 6. 강제형 변환 함수

1. as.character(x}

2. as.complex(x)      

3. as.numeric(x)               

4. as.double(x)                         

5. as.integer(x)                  

6. as.logical(x)



## 7. 자료형 또는 구조 확인 함수

class(x), str(x), mode(x), typeof(x)







# R의 데이터 셋

1. 벡터(팩터): 주로 1차원

2. 행렬: 2차원

3. 배열: 행렬이 여러개. 3차원. 
   - 잘 쓸 일이 없다. 딥러닝 때는 쓸 일이 있지만 그 외 일반적 데이터 분석에는 행렬까지 하면 충분.

4. 데이터프레임

5. 리스트

-> 총 5개의 데이터 셋이 존재한다.

![](C:\Users\salient\Pictures\데이터셋.png)

- __동일한 유형의 데이터__:

  - array(배열), matrix(행렬), vector(벡터), scala(스칼라), factor(요인)

  - __동일한 타입의 데이터만 저장 가능__

  - 예) 모두 숫자형, 모두 문자형 등

  - 스칼라: 벡터에 포함된다. 하나의 데이터 타입. element가 1개인 벡터. 

    but R의 기본 데이터는 아니다. 벡터가 가장 작음. 
    
    

- __서로 다른 유형의 데이터__: (데이터 프레임: 가장 많이 쓰임)

  - 구조로 보면 행렬과 비슷, 2차원.



![](C:\Users\salient\Pictures\데이터셋2.png)







## 1. 벡터(Vector)

![](C:\Users\salient\Pictures\벡터.png)

- R 에서 다루는 __가장 기초적인 데이터셋(데이터 구조)__로서 1차원으로 사용된다.
- 하나의 데이터 값도 벡터로 취급된다.
- __동일 타입의 데이터만__으로 구성된다.
  - 문자형(character) >수치형(numeric) > 논리형(logical))
- 벡터 생성 방법 : c(), seq(), rep(), __:__ 연산자
  - __c()__: 두 개 이상의 원소를 갖는 벡터들을 c() 함수의 인수로 준다.
    - ex) c(1,2,3,4,5); c("100", "200", "삼백"); c(T, R, R, T)
  - __seq()__: 숫자 간의 간격을 1 이외의 숫자로 줄 때
    - ex) seq(1, 10); seq(1, 10, 2); seq(0, 100, 5)
  - __rep()__: 주어진 값을 반복 사용
    - rep(1, 100) : 1을 100번 반복
    - rep(1:3, 5) : 1부터 3을 5번 반복
    - rep(1:3, times=5) :  (times:키워드 파라미터) 위와 같은 결과
    - rep(1:3, each=5) : (each:키워드 파라미터) 각각 반복(1-5개, 2-5개, 3-5개)
  - __: 연산자__: 하나씩 증가 또는 감소하는 숫자 벡터
    - v1 = 1:10; 1:10 -> v1

- 미리 정의된 내장 상수 벡터들 : LETTERS, letters, month.name, month.abb, pi

  - __LETTERS__: 대문자 알파벳
  - __letters__: 소문자 알파벳
  - __month.name__: 월별 이름
  - __month.abb__: 간축된 월별 이름
  - __pi__: pi 원주율

- 인덱싱 : __1__부터 시작하는 인텍스값과 [ 인덱스 ] 연산자 사용

  

  ### 주요 함수

  __length(v)__: 벡터의 element 갯수를 셀 때

  __names(v)__: 벡터에 이름을 부여할 때 (element 마다도 이름 부여 가능)

  __sort(v)__: accendent 나열 ; <-> __sort(v, decreasing = TRUE)__: decendent 나열

  __order(v)__: 인덱스 나열, accendent 나열. 가장 작은 element값부터 순서대로 인덱스를 나열함

  ___

  __class(v)__: 데이터의 타입을 체크

  __range(v)__: 최소값, 최대값을 출력

  __rev(v)__: 이 함수에서만 새로운 벡터를 리턴함(기존 벡터는 변경 없음)

  __max(v)__; 최대값

  __min(v)__; 최소값

  __mean(v)__; 평균

  __sum(v)__; 총 합

  __summary(v)__; 수치 데이터들 모두 보여줌

  __ls(v)__; 벡터를 모두 보여줌

  __rm(v)__; 벡터 삭제

  __sample(v)__; 랜덤 추출

  - sample(1:20, 3);  1~20 중 3개 랜덤 추출
  - sample(1:10, 7, replace=T) ; replace=T: 중복해도 상관 없을 때 

  __paste(v)__; element들을 하나로 결합해줌

  - paste("I'm","Duli","!!", sep=""); "I'mDuli!!"

  - fruit <- c("Apple", "Banana", "Strawberry")
    food <- c("Pie","Juice", "Cake")
    paste(fruit, food)

    ; "Apple Pie"       "Banana Juice"    "Strawberry Cake"

  __which(v)__; 

  

예시)

__rainfall <- c(21.6, 23.6, 45.8, 77.0, 102.2, 133.3,327.9, 348.0,137.6, 49.3, 53.0, 24.9)__
__rainfall > 100__; boolean 값으로 나타남 
__rainfall[rainfall > 100]__; rainfall 중에서 100 이상의 값인 rainfall 값을 나타냄
__which(rainfall > 100)__;위와 같은 결과
__month.name[which(rainfall > 100)]__; 100이상인 값의 인덱스를 달 이름으로 표기
__month.abb[which(rainfall > 100)]__
__month.korname <- c("1월","2월","3월","4월","5월","6월","7월","8월","9월","10월","11월","12월")__
__month.korname[which(rainfall > 100)]__
__which.max(rainfall)__
__which.min(rainfall)__
__month.korname[which.max(rainfall)]__
__month.korname[which.min(rainfall)]__







## 2. 행렬(Matrix)

![](C:\Users\salient\Pictures\행렬.png)



![](C:\Users\salient\Pictures\행열.png)

<img src="C:\Users\salient\Pictures\행과열.png" style="zoom:40%;" />

- 행(row, 가로)과 열(column, 세로)로 구성됨.

- __2차원의 벡터__이다. 

- __동일타입의 데이터만__ 저장 가능

- 인덱싱 : __[행의인덱싱, 열의인덱싱]__ ,[행의인덱싱, ], [, 열의인덱싱]

   - default: 열부터 데이터를 채운다. 즉, 데이터가 다 열로 들어간다.

     ex) x1 <-matrix(1:8);  1~8을 8행 1열(행 갯수를 안줘서, 열부터 채운다.)

     x1 <-matrix(1:8, nrow = 2);  1~8을 2행 4열

- 행렬 생성방법 : 
  - matrix(data=벡터, nrow=행의갯수, ncol=열의갯수)
  - matrix(data=벡터, nrow=행의갯수, ncol=열의갯수, byrow=TRUE)
    - 행을 먼저 채움
    - byrow=T: 행의 방향으로 데이터를 채움
    - default; bybrow = false

- rbind(v1, v2, ..), cbind(v1, v2, ..): 벡터 간 결합, 벡터와 행렬을 결합
  - ex) mat1 <- rbind(vec1,vec2,vec3);  vec1, vec2, vec3을 행으로 받음
  - mat2 <- cbind(vec1,vec2,vec3);  vec1, vec2, vec3을 열로 받음 

- drop 속성을 사용해서 행렬구조 유지
  - mat1[1,1,drop=F]: mat1의 구조를 유지한 채로 (1,1)의 데이터값 추출



		###    주요함수

​	__dim(m)__: 행렬이 몇 차원(몇 행 몇 열)인지 체크. 

​	__nrow__(행의 갯수), __ncol__(열의 갯수)

​	__rownames(m)__, __colnames(m)__: 행 이름, 열 이름

​	__rowSums(m)__, __colSums(m)__: 행 총합, 열 총합

​	__rowMeans(m)__, __colMeans(m)__: 행 평균, 열 평균

​	__apply(m, 방향, 처리할 내용)__: 방향(1: 행, 2: 열)

- apply(x2, 1, sum); 같은 행에 있는 값들을 더함

- apply(x2, 2, sum); 같은 열에 있는 값들을 더함



## 3. 배열(Array)

![](C:\Users\salient\Pictures\배열.png)

- __3차원 벡터__이다.

- __동일타입의 데이터만__ 저장 가능

- 인덱싱 : [행의인덱싱, 열의인덱싱, 층(면)의인덱스]